"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _object = _interopRequireDefault(require("object.entries-ponyfill"));

var _iterateJsdoc = _interopRequireDefault(require("../iterateJsdoc"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

const defaultTags = {
  file: {
    initialCommentsOnly: true,
    mustExist: true,
    preventDuplicates: true
  }
};

const setDefaults = state => {
  // First iteration
  if (!state.globalTags) {
    state.globalTags = {};
    state.hasDuplicates = {};
    state.hasTag = {};
    state.hasNonCommentBeforeTag = {};
  }
};

var _default = (0, _iterateJsdoc.default)(({
  jsdocNode,
  state,
  utils,
  context
}) => {
  const _ref = context.options[0] || {},
        _ref$tags = _ref.tags,
        tags = _ref$tags === void 0 ? defaultTags : _ref$tags;

  setDefaults(state);

  for (var _i = 0, _Object$keys = Object.keys(tags); _i < _Object$keys.length; _i++) {
    const tagName = _Object$keys[_i];
    const targetTagName = utils.getPreferredTagName({
      tagName
    });
    const hasTag = targetTagName && utils.hasTag(targetTagName);
    state.hasTag[tagName] = hasTag || state.hasTag[tagName];
    const hasDuplicate = state.hasDuplicates[tagName];

    if (hasDuplicate === false) {
      // Was marked before, so if a tag now, is a dupe
      state.hasDuplicates[tagName] = hasTag;
    } else if (!hasDuplicate && hasTag) {
      // No dupes set before, but has first tag, so change state
      //   from `undefined` to `false` so can detect next time
      state.hasDuplicates[tagName] = false;
      state.hasNonCommentBeforeTag[tagName] = state.hasNonComment && state.hasNonComment < jsdocNode.start;
    }
  }
}, {
  exit({
    context,
    state,
    utils
  }) {
    setDefaults(state);

    const _ref2 = context.options[0] || {},
          _ref2$tags = _ref2.tags,
          tags = _ref2$tags === void 0 ? defaultTags : _ref2$tags;

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = (0, _object.default)(tags)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        const _step$value = _slicedToArray(_step.value, 2),
              tagName = _step$value[0],
              _step$value$ = _step$value[1],
              _step$value$$mustExis = _step$value$.mustExist,
              mustExist = _step$value$$mustExis === void 0 ? false : _step$value$$mustExis,
              _step$value$$preventD = _step$value$.preventDuplicates,
              preventDuplicates = _step$value$$preventD === void 0 ? false : _step$value$$preventD,
              _step$value$$initialC = _step$value$.initialCommentsOnly,
              initialCommentsOnly = _step$value$$initialC === void 0 ? false : _step$value$$initialC;

        const obj = utils.getPreferredTagNameObject({
          tagName
        });

        if (obj && obj.blocked) {
          utils.reportSettings(`\`settings.jsdoc.tagNamePreference\` cannot block @${obj.tagName} ` + 'for the `require-file-overview` rule');
        } else {
          const targetTagName = obj && obj.replacement || obj;

          if (mustExist && !state.hasTag[tagName]) {
            utils.reportSettings(`Missing @${targetTagName}`);
          }

          if (preventDuplicates && state.hasDuplicates[tagName]) {
            utils.reportSettings(`Duplicate @${targetTagName}`);
          }

          if (initialCommentsOnly && state.hasNonCommentBeforeTag[tagName]) {
            utils.reportSettings(`@${targetTagName} should be at the beginning of the file`);
          }
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  },

  iterateAllJsdocs: true,
  meta: {
    schema: [{
      additionalProperties: false,
      properties: {
        tags: {
          patternProperties: {
            '.*': {
              additionalProperties: false,
              properties: {
                initialCommentsOnly: {
                  type: 'boolean'
                },
                mustExist: {
                  type: 'boolean'
                },
                preventDuplicates: {
                  type: 'boolean'
                }
              },
              type: 'object'
            }
          },
          type: 'object'
        }
      },
      type: 'object'
    }],
    type: 'suggestion'
  },

  nonComment({
    state,
    node
  }) {
    if (!state.hasNonComment) {
      state.hasNonComment = node.start;
    }
  }

});

exports.default = _default;
module.exports = exports.default;
//# sourceMappingURL=requireFileOverview.js.map